// Code generated by Prisma (prisma@1.25.7). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  job: (where?: JobWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  team: (where?: TeamWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  job: (where: JobWhereUniqueInput) => JobPromise;
  jobs: (args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Job>;
  jobsConnection: (args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => JobConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagPromise;
  tags: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tag>;
  tagsConnection: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TagConnectionPromise;
  team: (where: TeamWhereUniqueInput) => TeamPromise;
  teams: (args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Team>;
  teamsConnection: (args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TeamConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createJob: (data: JobCreateInput) => JobPromise;
  updateJob: (args: {
    data: JobUpdateInput;
    where: JobWhereUniqueInput;
  }) => JobPromise;
  updateManyJobs: (args: {
    data: JobUpdateManyMutationInput;
    where?: JobWhereInput;
  }) => BatchPayloadPromise;
  upsertJob: (args: {
    where: JobWhereUniqueInput;
    create: JobCreateInput;
    update: JobUpdateInput;
  }) => JobPromise;
  deleteJob: (where: JobWhereUniqueInput) => JobPromise;
  deleteManyJobs: (where?: JobWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (args: {
    data: TagUpdateInput;
    where: TagWhereUniqueInput;
  }) => TagPromise;
  updateManyTags: (args: {
    data: TagUpdateManyMutationInput;
    where?: TagWhereInput;
  }) => BatchPayloadPromise;
  upsertTag: (args: {
    where: TagWhereUniqueInput;
    create: TagCreateInput;
    update: TagUpdateInput;
  }) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createTeam: (data: TeamCreateInput) => TeamPromise;
  updateTeam: (args: {
    data: TeamUpdateInput;
    where: TeamWhereUniqueInput;
  }) => TeamPromise;
  updateManyTeams: (args: {
    data: TeamUpdateManyMutationInput;
    where?: TeamWhereInput;
  }) => BatchPayloadPromise;
  upsertTeam: (args: {
    where: TeamWhereUniqueInput;
    create: TeamCreateInput;
    update: TeamUpdateInput;
  }) => TeamPromise;
  deleteTeam: (where: TeamWhereUniqueInput) => TeamPromise;
  deleteManyTeams: (where?: TeamWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  job: (
    where?: JobSubscriptionWhereInput
  ) => JobSubscriptionPayloadSubscription;
  member: (
    where?: MemberSubscriptionWhereInput
  ) => MemberSubscriptionPayloadSubscription;
  scoredTag: (
    where?: ScoredTagSubscriptionWhereInput
  ) => ScoredTagSubscriptionPayloadSubscription;
  socialAccount: (
    where?: SocialAccountSubscriptionWhereInput
  ) => SocialAccountSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  team: (
    where?: TeamSubscriptionWhereInput
  ) => TeamSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type RoleType = "ADMIN" | "MEMBER";

export type TeamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "enabled_ASC"
  | "enabled_DESC"
  | "name_ASC"
  | "name_DESC"
  | "header_ASC"
  | "header_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "createdByUserId_ASC"
  | "createdByUserId_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "updatedByUserId_ASC"
  | "updatedByUserId_DESC";

export type SocialAccountType = "LINKEDIN" | "GITHUB";

export type JobOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "enabled_ASC"
  | "enabled_DESC"
  | "name_ASC"
  | "name_DESC"
  | "header_ASC"
  | "header_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "createdByUserId_ASC"
  | "createdByUserId_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "updatedByUserId_ASC"
  | "updatedByUserId_DESC";

export type TagOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "available_ASC"
  | "available_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "createdByUserId_ASC"
  | "createdByUserId_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "updatedByUserId_ASC"
  | "updatedByUserId_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type JobWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  createdByUserId?: ID_Input;
  updatedByUserId?: ID_Input;
}>;

export interface TeamWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  enabled?: Boolean;
  enabled_not?: Boolean;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  header?: String;
  header_not?: String;
  header_in?: String[] | String;
  header_not_in?: String[] | String;
  header_lt?: String;
  header_lte?: String;
  header_gt?: String;
  header_gte?: String;
  header_contains?: String;
  header_not_contains?: String;
  header_starts_with?: String;
  header_not_starts_with?: String;
  header_ends_with?: String;
  header_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  createdByUserId?: ID_Input;
  createdByUserId_not?: ID_Input;
  createdByUserId_in?: ID_Input[] | ID_Input;
  createdByUserId_not_in?: ID_Input[] | ID_Input;
  createdByUserId_lt?: ID_Input;
  createdByUserId_lte?: ID_Input;
  createdByUserId_gt?: ID_Input;
  createdByUserId_gte?: ID_Input;
  createdByUserId_contains?: ID_Input;
  createdByUserId_not_contains?: ID_Input;
  createdByUserId_starts_with?: ID_Input;
  createdByUserId_not_starts_with?: ID_Input;
  createdByUserId_ends_with?: ID_Input;
  createdByUserId_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  updatedByUserId?: ID_Input;
  updatedByUserId_not?: ID_Input;
  updatedByUserId_in?: ID_Input[] | ID_Input;
  updatedByUserId_not_in?: ID_Input[] | ID_Input;
  updatedByUserId_lt?: ID_Input;
  updatedByUserId_lte?: ID_Input;
  updatedByUserId_gt?: ID_Input;
  updatedByUserId_gte?: ID_Input;
  updatedByUserId_contains?: ID_Input;
  updatedByUserId_not_contains?: ID_Input;
  updatedByUserId_starts_with?: ID_Input;
  updatedByUserId_not_starts_with?: ID_Input;
  updatedByUserId_ends_with?: ID_Input;
  updatedByUserId_not_ends_with?: ID_Input;
  members_every?: MemberWhereInput;
  members_some?: MemberWhereInput;
  members_none?: MemberWhereInput;
  tags_every?: ScoredTagWhereInput;
  tags_some?: ScoredTagWhereInput;
  tags_none?: ScoredTagWhereInput;
  AND?: TeamWhereInput[] | TeamWhereInput;
  OR?: TeamWhereInput[] | TeamWhereInput;
  NOT?: TeamWhereInput[] | TeamWhereInput;
}

export interface MemberWhereInput {
  role?: RoleType;
  role_not?: RoleType;
  role_in?: RoleType[] | RoleType;
  role_not_in?: RoleType[] | RoleType;
  noticePeriod?: Int;
  noticePeriod_not?: Int;
  noticePeriod_in?: Int[] | Int;
  noticePeriod_not_in?: Int[] | Int;
  noticePeriod_lt?: Int;
  noticePeriod_lte?: Int;
  noticePeriod_gt?: Int;
  noticePeriod_gte?: Int;
  availableAt?: DateTimeInput;
  availableAt_not?: DateTimeInput;
  availableAt_in?: DateTimeInput[] | DateTimeInput;
  availableAt_not_in?: DateTimeInput[] | DateTimeInput;
  availableAt_lt?: DateTimeInput;
  availableAt_lte?: DateTimeInput;
  availableAt_gt?: DateTimeInput;
  availableAt_gte?: DateTimeInput;
  AND?: MemberWhereInput[] | MemberWhereInput;
  OR?: MemberWhereInput[] | MemberWhereInput;
  NOT?: MemberWhereInput[] | MemberWhereInput;
}

export interface ScoredTagWhereInput {
  score?: Int;
  score_not?: Int;
  score_in?: Int[] | Int;
  score_not_in?: Int[] | Int;
  score_lt?: Int;
  score_lte?: Int;
  score_gt?: Int;
  score_gte?: Int;
  AND?: ScoredTagWhereInput[] | ScoredTagWhereInput;
  OR?: ScoredTagWhereInput[] | ScoredTagWhereInput;
  NOT?: ScoredTagWhereInput[] | ScoredTagWhereInput;
}

export interface JobWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  enabled?: Boolean;
  enabled_not?: Boolean;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  header?: String;
  header_not?: String;
  header_in?: String[] | String;
  header_not_in?: String[] | String;
  header_lt?: String;
  header_lte?: String;
  header_gt?: String;
  header_gte?: String;
  header_contains?: String;
  header_not_contains?: String;
  header_starts_with?: String;
  header_not_starts_with?: String;
  header_ends_with?: String;
  header_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  createdByUserId?: ID_Input;
  createdByUserId_not?: ID_Input;
  createdByUserId_in?: ID_Input[] | ID_Input;
  createdByUserId_not_in?: ID_Input[] | ID_Input;
  createdByUserId_lt?: ID_Input;
  createdByUserId_lte?: ID_Input;
  createdByUserId_gt?: ID_Input;
  createdByUserId_gte?: ID_Input;
  createdByUserId_contains?: ID_Input;
  createdByUserId_not_contains?: ID_Input;
  createdByUserId_starts_with?: ID_Input;
  createdByUserId_not_starts_with?: ID_Input;
  createdByUserId_ends_with?: ID_Input;
  createdByUserId_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  updatedByUserId?: ID_Input;
  updatedByUserId_not?: ID_Input;
  updatedByUserId_in?: ID_Input[] | ID_Input;
  updatedByUserId_not_in?: ID_Input[] | ID_Input;
  updatedByUserId_lt?: ID_Input;
  updatedByUserId_lte?: ID_Input;
  updatedByUserId_gt?: ID_Input;
  updatedByUserId_gte?: ID_Input;
  updatedByUserId_contains?: ID_Input;
  updatedByUserId_not_contains?: ID_Input;
  updatedByUserId_starts_with?: ID_Input;
  updatedByUserId_not_starts_with?: ID_Input;
  updatedByUserId_ends_with?: ID_Input;
  updatedByUserId_not_ends_with?: ID_Input;
  tags_every?: ScoredTagWhereInput;
  tags_some?: ScoredTagWhereInput;
  tags_none?: ScoredTagWhereInput;
  AND?: JobWhereInput[] | JobWhereInput;
  OR?: JobWhereInput[] | JobWhereInput;
  NOT?: JobWhereInput[] | JobWhereInput;
}

export type TagWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TagWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: TagWhereInput[] | TagWhereInput;
  OR?: TagWhereInput[] | TagWhereInput;
  NOT?: TagWhereInput[] | TagWhereInput;
}

export type TeamWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  createdByUserId?: ID_Input;
  updatedByUserId?: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
  createdByUserId?: ID_Input;
  updatedByUserId?: ID_Input;
}>;

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  available?: Boolean;
  available_not?: Boolean;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  socialAccounts_every?: SocialAccountWhereInput;
  socialAccounts_some?: SocialAccountWhereInput;
  socialAccounts_none?: SocialAccountWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  createdByUserId?: ID_Input;
  createdByUserId_not?: ID_Input;
  createdByUserId_in?: ID_Input[] | ID_Input;
  createdByUserId_not_in?: ID_Input[] | ID_Input;
  createdByUserId_lt?: ID_Input;
  createdByUserId_lte?: ID_Input;
  createdByUserId_gt?: ID_Input;
  createdByUserId_gte?: ID_Input;
  createdByUserId_contains?: ID_Input;
  createdByUserId_not_contains?: ID_Input;
  createdByUserId_starts_with?: ID_Input;
  createdByUserId_not_starts_with?: ID_Input;
  createdByUserId_ends_with?: ID_Input;
  createdByUserId_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  updatedByUserId?: ID_Input;
  updatedByUserId_not?: ID_Input;
  updatedByUserId_in?: ID_Input[] | ID_Input;
  updatedByUserId_not_in?: ID_Input[] | ID_Input;
  updatedByUserId_lt?: ID_Input;
  updatedByUserId_lte?: ID_Input;
  updatedByUserId_gt?: ID_Input;
  updatedByUserId_gte?: ID_Input;
  updatedByUserId_contains?: ID_Input;
  updatedByUserId_not_contains?: ID_Input;
  updatedByUserId_starts_with?: ID_Input;
  updatedByUserId_not_starts_with?: ID_Input;
  updatedByUserId_ends_with?: ID_Input;
  updatedByUserId_not_ends_with?: ID_Input;
  tags_every?: ScoredTagWhereInput;
  tags_some?: ScoredTagWhereInput;
  tags_none?: ScoredTagWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface SocialAccountWhereInput {
  externalId?: String;
  externalId_not?: String;
  externalId_in?: String[] | String;
  externalId_not_in?: String[] | String;
  externalId_lt?: String;
  externalId_lte?: String;
  externalId_gt?: String;
  externalId_gte?: String;
  externalId_contains?: String;
  externalId_not_contains?: String;
  externalId_starts_with?: String;
  externalId_not_starts_with?: String;
  externalId_ends_with?: String;
  externalId_not_ends_with?: String;
  type?: SocialAccountType;
  type_not?: SocialAccountType;
  type_in?: SocialAccountType[] | SocialAccountType;
  type_not_in?: SocialAccountType[] | SocialAccountType;
  AND?: SocialAccountWhereInput[] | SocialAccountWhereInput;
  OR?: SocialAccountWhereInput[] | SocialAccountWhereInput;
  NOT?: SocialAccountWhereInput[] | SocialAccountWhereInput;
}

export interface JobCreateInput {
  enabled?: Boolean;
  name: String;
  header?: String;
  description?: String;
  applications?: TeamCreateManyWithoutJobsAppliedToInput;
  tags?: ScoredTagCreateManyInput;
}

export interface TeamCreateManyWithoutJobsAppliedToInput {
  create?:
    | TeamCreateWithoutJobsAppliedToInput[]
    | TeamCreateWithoutJobsAppliedToInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
}

export interface TeamCreateWithoutJobsAppliedToInput {
  enabled?: Boolean;
  name: String;
  header?: String;
  description?: String;
  members?: MemberCreateManyInput;
  tags?: ScoredTagCreateManyInput;
}

export interface MemberCreateManyInput {
  create?: MemberCreateInput[] | MemberCreateInput;
}

export interface MemberCreateInput {
  user: UserCreateOneInput;
  role: RoleType;
  noticePeriod?: Int;
  availableAt?: DateTimeInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateInput {
  email?: String;
  available: Boolean;
  firstName: String;
  lastName: String;
  description: String;
  socialAccounts?: SocialAccountCreateManyInput;
  jobsCreated?: JobCreateManyInput;
  tags?: ScoredTagCreateManyInput;
}

export interface SocialAccountCreateManyInput {
  create?: SocialAccountCreateInput[] | SocialAccountCreateInput;
}

export interface SocialAccountCreateInput {
  externalId: String;
  type: SocialAccountType;
}

export interface JobCreateManyInput {
  create?: JobCreateInput[] | JobCreateInput;
  connect?: JobWhereUniqueInput[] | JobWhereUniqueInput;
}

export interface ScoredTagCreateManyInput {
  create?: ScoredTagCreateInput[] | ScoredTagCreateInput;
}

export interface ScoredTagCreateInput {
  score?: Int;
  tag?: TagCreateOneInput;
}

export interface TagCreateOneInput {
  create?: TagCreateInput;
  connect?: TagWhereUniqueInput;
}

export interface TagCreateInput {
  name: String;
}

export interface JobUpdateInput {
  enabled?: Boolean;
  name?: String;
  header?: String;
  description?: String;
  applications?: TeamUpdateManyWithoutJobsAppliedToInput;
  tags?: ScoredTagUpdateManyInput;
}

export interface TeamUpdateManyWithoutJobsAppliedToInput {
  create?:
    | TeamCreateWithoutJobsAppliedToInput[]
    | TeamCreateWithoutJobsAppliedToInput;
  delete?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  connect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  disconnect?: TeamWhereUniqueInput[] | TeamWhereUniqueInput;
  update?:
    | TeamUpdateWithWhereUniqueWithoutJobsAppliedToInput[]
    | TeamUpdateWithWhereUniqueWithoutJobsAppliedToInput;
  upsert?:
    | TeamUpsertWithWhereUniqueWithoutJobsAppliedToInput[]
    | TeamUpsertWithWhereUniqueWithoutJobsAppliedToInput;
  deleteMany?: TeamScalarWhereInput[] | TeamScalarWhereInput;
  updateMany?:
    | TeamUpdateManyWithWhereNestedInput[]
    | TeamUpdateManyWithWhereNestedInput;
}

export interface TeamUpdateWithWhereUniqueWithoutJobsAppliedToInput {
  where: TeamWhereUniqueInput;
  data: TeamUpdateWithoutJobsAppliedToDataInput;
}

export interface TeamUpdateWithoutJobsAppliedToDataInput {
  enabled?: Boolean;
  name?: String;
  header?: String;
  description?: String;
  members?: MemberUpdateManyInput;
  tags?: ScoredTagUpdateManyInput;
}

export interface MemberUpdateManyInput {
  create?: MemberCreateInput[] | MemberCreateInput;
  deleteMany?: MemberScalarWhereInput[] | MemberScalarWhereInput;
  updateMany?:
    | MemberUpdateManyWithWhereNestedInput[]
    | MemberUpdateManyWithWhereNestedInput;
}

export interface MemberScalarWhereInput {
  role?: RoleType;
  role_not?: RoleType;
  role_in?: RoleType[] | RoleType;
  role_not_in?: RoleType[] | RoleType;
  noticePeriod?: Int;
  noticePeriod_not?: Int;
  noticePeriod_in?: Int[] | Int;
  noticePeriod_not_in?: Int[] | Int;
  noticePeriod_lt?: Int;
  noticePeriod_lte?: Int;
  noticePeriod_gt?: Int;
  noticePeriod_gte?: Int;
  availableAt?: DateTimeInput;
  availableAt_not?: DateTimeInput;
  availableAt_in?: DateTimeInput[] | DateTimeInput;
  availableAt_not_in?: DateTimeInput[] | DateTimeInput;
  availableAt_lt?: DateTimeInput;
  availableAt_lte?: DateTimeInput;
  availableAt_gt?: DateTimeInput;
  availableAt_gte?: DateTimeInput;
  AND?: MemberScalarWhereInput[] | MemberScalarWhereInput;
  OR?: MemberScalarWhereInput[] | MemberScalarWhereInput;
  NOT?: MemberScalarWhereInput[] | MemberScalarWhereInput;
}

export interface MemberUpdateManyWithWhereNestedInput {
  where: MemberScalarWhereInput;
  data: MemberUpdateManyDataInput;
}

export interface MemberUpdateManyDataInput {
  role?: RoleType;
  noticePeriod?: Int;
  availableAt?: DateTimeInput;
}

export interface ScoredTagUpdateManyInput {
  create?: ScoredTagCreateInput[] | ScoredTagCreateInput;
  deleteMany?: ScoredTagScalarWhereInput[] | ScoredTagScalarWhereInput;
  updateMany?:
    | ScoredTagUpdateManyWithWhereNestedInput[]
    | ScoredTagUpdateManyWithWhereNestedInput;
}

export interface ScoredTagScalarWhereInput {
  score?: Int;
  score_not?: Int;
  score_in?: Int[] | Int;
  score_not_in?: Int[] | Int;
  score_lt?: Int;
  score_lte?: Int;
  score_gt?: Int;
  score_gte?: Int;
  AND?: ScoredTagScalarWhereInput[] | ScoredTagScalarWhereInput;
  OR?: ScoredTagScalarWhereInput[] | ScoredTagScalarWhereInput;
  NOT?: ScoredTagScalarWhereInput[] | ScoredTagScalarWhereInput;
}

export interface ScoredTagUpdateManyWithWhereNestedInput {
  where: ScoredTagScalarWhereInput;
  data: ScoredTagUpdateManyDataInput;
}

export interface ScoredTagUpdateManyDataInput {
  score?: Int;
}

export interface TeamUpsertWithWhereUniqueWithoutJobsAppliedToInput {
  where: TeamWhereUniqueInput;
  update: TeamUpdateWithoutJobsAppliedToDataInput;
  create: TeamCreateWithoutJobsAppliedToInput;
}

export interface TeamScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  enabled?: Boolean;
  enabled_not?: Boolean;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  header?: String;
  header_not?: String;
  header_in?: String[] | String;
  header_not_in?: String[] | String;
  header_lt?: String;
  header_lte?: String;
  header_gt?: String;
  header_gte?: String;
  header_contains?: String;
  header_not_contains?: String;
  header_starts_with?: String;
  header_not_starts_with?: String;
  header_ends_with?: String;
  header_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  createdByUserId?: ID_Input;
  createdByUserId_not?: ID_Input;
  createdByUserId_in?: ID_Input[] | ID_Input;
  createdByUserId_not_in?: ID_Input[] | ID_Input;
  createdByUserId_lt?: ID_Input;
  createdByUserId_lte?: ID_Input;
  createdByUserId_gt?: ID_Input;
  createdByUserId_gte?: ID_Input;
  createdByUserId_contains?: ID_Input;
  createdByUserId_not_contains?: ID_Input;
  createdByUserId_starts_with?: ID_Input;
  createdByUserId_not_starts_with?: ID_Input;
  createdByUserId_ends_with?: ID_Input;
  createdByUserId_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  updatedByUserId?: ID_Input;
  updatedByUserId_not?: ID_Input;
  updatedByUserId_in?: ID_Input[] | ID_Input;
  updatedByUserId_not_in?: ID_Input[] | ID_Input;
  updatedByUserId_lt?: ID_Input;
  updatedByUserId_lte?: ID_Input;
  updatedByUserId_gt?: ID_Input;
  updatedByUserId_gte?: ID_Input;
  updatedByUserId_contains?: ID_Input;
  updatedByUserId_not_contains?: ID_Input;
  updatedByUserId_starts_with?: ID_Input;
  updatedByUserId_not_starts_with?: ID_Input;
  updatedByUserId_ends_with?: ID_Input;
  updatedByUserId_not_ends_with?: ID_Input;
  AND?: TeamScalarWhereInput[] | TeamScalarWhereInput;
  OR?: TeamScalarWhereInput[] | TeamScalarWhereInput;
  NOT?: TeamScalarWhereInput[] | TeamScalarWhereInput;
}

export interface TeamUpdateManyWithWhereNestedInput {
  where: TeamScalarWhereInput;
  data: TeamUpdateManyDataInput;
}

export interface TeamUpdateManyDataInput {
  enabled?: Boolean;
  name?: String;
  header?: String;
  description?: String;
}

export interface JobUpdateManyMutationInput {
  enabled?: Boolean;
  name?: String;
  header?: String;
  description?: String;
}

export interface TagUpdateInput {
  name?: String;
}

export interface TagUpdateManyMutationInput {
  name?: String;
}

export interface TeamCreateInput {
  enabled?: Boolean;
  name: String;
  header?: String;
  description?: String;
  members?: MemberCreateManyInput;
  jobsAppliedTo?: JobCreateManyWithoutApplicationsInput;
  tags?: ScoredTagCreateManyInput;
}

export interface JobCreateManyWithoutApplicationsInput {
  create?:
    | JobCreateWithoutApplicationsInput[]
    | JobCreateWithoutApplicationsInput;
  connect?: JobWhereUniqueInput[] | JobWhereUniqueInput;
}

export interface JobCreateWithoutApplicationsInput {
  enabled?: Boolean;
  name: String;
  header?: String;
  description?: String;
  tags?: ScoredTagCreateManyInput;
}

export interface TeamUpdateInput {
  enabled?: Boolean;
  name?: String;
  header?: String;
  description?: String;
  members?: MemberUpdateManyInput;
  jobsAppliedTo?: JobUpdateManyWithoutApplicationsInput;
  tags?: ScoredTagUpdateManyInput;
}

export interface JobUpdateManyWithoutApplicationsInput {
  create?:
    | JobCreateWithoutApplicationsInput[]
    | JobCreateWithoutApplicationsInput;
  delete?: JobWhereUniqueInput[] | JobWhereUniqueInput;
  connect?: JobWhereUniqueInput[] | JobWhereUniqueInput;
  disconnect?: JobWhereUniqueInput[] | JobWhereUniqueInput;
  update?:
    | JobUpdateWithWhereUniqueWithoutApplicationsInput[]
    | JobUpdateWithWhereUniqueWithoutApplicationsInput;
  upsert?:
    | JobUpsertWithWhereUniqueWithoutApplicationsInput[]
    | JobUpsertWithWhereUniqueWithoutApplicationsInput;
  deleteMany?: JobScalarWhereInput[] | JobScalarWhereInput;
  updateMany?:
    | JobUpdateManyWithWhereNestedInput[]
    | JobUpdateManyWithWhereNestedInput;
}

export interface JobUpdateWithWhereUniqueWithoutApplicationsInput {
  where: JobWhereUniqueInput;
  data: JobUpdateWithoutApplicationsDataInput;
}

export interface JobUpdateWithoutApplicationsDataInput {
  enabled?: Boolean;
  name?: String;
  header?: String;
  description?: String;
  tags?: ScoredTagUpdateManyInput;
}

export interface JobUpsertWithWhereUniqueWithoutApplicationsInput {
  where: JobWhereUniqueInput;
  update: JobUpdateWithoutApplicationsDataInput;
  create: JobCreateWithoutApplicationsInput;
}

export interface JobScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  enabled?: Boolean;
  enabled_not?: Boolean;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  header?: String;
  header_not?: String;
  header_in?: String[] | String;
  header_not_in?: String[] | String;
  header_lt?: String;
  header_lte?: String;
  header_gt?: String;
  header_gte?: String;
  header_contains?: String;
  header_not_contains?: String;
  header_starts_with?: String;
  header_not_starts_with?: String;
  header_ends_with?: String;
  header_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  createdByUserId?: ID_Input;
  createdByUserId_not?: ID_Input;
  createdByUserId_in?: ID_Input[] | ID_Input;
  createdByUserId_not_in?: ID_Input[] | ID_Input;
  createdByUserId_lt?: ID_Input;
  createdByUserId_lte?: ID_Input;
  createdByUserId_gt?: ID_Input;
  createdByUserId_gte?: ID_Input;
  createdByUserId_contains?: ID_Input;
  createdByUserId_not_contains?: ID_Input;
  createdByUserId_starts_with?: ID_Input;
  createdByUserId_not_starts_with?: ID_Input;
  createdByUserId_ends_with?: ID_Input;
  createdByUserId_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  updatedByUserId?: ID_Input;
  updatedByUserId_not?: ID_Input;
  updatedByUserId_in?: ID_Input[] | ID_Input;
  updatedByUserId_not_in?: ID_Input[] | ID_Input;
  updatedByUserId_lt?: ID_Input;
  updatedByUserId_lte?: ID_Input;
  updatedByUserId_gt?: ID_Input;
  updatedByUserId_gte?: ID_Input;
  updatedByUserId_contains?: ID_Input;
  updatedByUserId_not_contains?: ID_Input;
  updatedByUserId_starts_with?: ID_Input;
  updatedByUserId_not_starts_with?: ID_Input;
  updatedByUserId_ends_with?: ID_Input;
  updatedByUserId_not_ends_with?: ID_Input;
  AND?: JobScalarWhereInput[] | JobScalarWhereInput;
  OR?: JobScalarWhereInput[] | JobScalarWhereInput;
  NOT?: JobScalarWhereInput[] | JobScalarWhereInput;
}

export interface JobUpdateManyWithWhereNestedInput {
  where: JobScalarWhereInput;
  data: JobUpdateManyDataInput;
}

export interface JobUpdateManyDataInput {
  enabled?: Boolean;
  name?: String;
  header?: String;
  description?: String;
}

export interface TeamUpdateManyMutationInput {
  enabled?: Boolean;
  name?: String;
  header?: String;
  description?: String;
}

export interface UserUpdateInput {
  email?: String;
  available?: Boolean;
  firstName?: String;
  lastName?: String;
  description?: String;
  socialAccounts?: SocialAccountUpdateManyInput;
  jobsCreated?: JobUpdateManyInput;
  tags?: ScoredTagUpdateManyInput;
}

export interface SocialAccountUpdateManyInput {
  create?: SocialAccountCreateInput[] | SocialAccountCreateInput;
  deleteMany?: SocialAccountScalarWhereInput[] | SocialAccountScalarWhereInput;
  updateMany?:
    | SocialAccountUpdateManyWithWhereNestedInput[]
    | SocialAccountUpdateManyWithWhereNestedInput;
}

export interface SocialAccountScalarWhereInput {
  externalId?: String;
  externalId_not?: String;
  externalId_in?: String[] | String;
  externalId_not_in?: String[] | String;
  externalId_lt?: String;
  externalId_lte?: String;
  externalId_gt?: String;
  externalId_gte?: String;
  externalId_contains?: String;
  externalId_not_contains?: String;
  externalId_starts_with?: String;
  externalId_not_starts_with?: String;
  externalId_ends_with?: String;
  externalId_not_ends_with?: String;
  type?: SocialAccountType;
  type_not?: SocialAccountType;
  type_in?: SocialAccountType[] | SocialAccountType;
  type_not_in?: SocialAccountType[] | SocialAccountType;
  AND?: SocialAccountScalarWhereInput[] | SocialAccountScalarWhereInput;
  OR?: SocialAccountScalarWhereInput[] | SocialAccountScalarWhereInput;
  NOT?: SocialAccountScalarWhereInput[] | SocialAccountScalarWhereInput;
}

export interface SocialAccountUpdateManyWithWhereNestedInput {
  where: SocialAccountScalarWhereInput;
  data: SocialAccountUpdateManyDataInput;
}

export interface SocialAccountUpdateManyDataInput {
  externalId?: String;
  type?: SocialAccountType;
}

export interface JobUpdateManyInput {
  create?: JobCreateInput[] | JobCreateInput;
  update?:
    | JobUpdateWithWhereUniqueNestedInput[]
    | JobUpdateWithWhereUniqueNestedInput;
  upsert?:
    | JobUpsertWithWhereUniqueNestedInput[]
    | JobUpsertWithWhereUniqueNestedInput;
  delete?: JobWhereUniqueInput[] | JobWhereUniqueInput;
  connect?: JobWhereUniqueInput[] | JobWhereUniqueInput;
  disconnect?: JobWhereUniqueInput[] | JobWhereUniqueInput;
  deleteMany?: JobScalarWhereInput[] | JobScalarWhereInput;
  updateMany?:
    | JobUpdateManyWithWhereNestedInput[]
    | JobUpdateManyWithWhereNestedInput;
}

export interface JobUpdateWithWhereUniqueNestedInput {
  where: JobWhereUniqueInput;
  data: JobUpdateDataInput;
}

export interface JobUpdateDataInput {
  enabled?: Boolean;
  name?: String;
  header?: String;
  description?: String;
  applications?: TeamUpdateManyWithoutJobsAppliedToInput;
  tags?: ScoredTagUpdateManyInput;
}

export interface JobUpsertWithWhereUniqueNestedInput {
  where: JobWhereUniqueInput;
  update: JobUpdateDataInput;
  create: JobCreateInput;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  available?: Boolean;
  firstName?: String;
  lastName?: String;
  description?: String;
}

export interface JobSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: JobWhereInput;
  AND?: JobSubscriptionWhereInput[] | JobSubscriptionWhereInput;
  OR?: JobSubscriptionWhereInput[] | JobSubscriptionWhereInput;
  NOT?: JobSubscriptionWhereInput[] | JobSubscriptionWhereInput;
}

export interface MemberSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MemberWhereInput;
  AND?: MemberSubscriptionWhereInput[] | MemberSubscriptionWhereInput;
  OR?: MemberSubscriptionWhereInput[] | MemberSubscriptionWhereInput;
  NOT?: MemberSubscriptionWhereInput[] | MemberSubscriptionWhereInput;
}

export interface ScoredTagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScoredTagWhereInput;
  AND?: ScoredTagSubscriptionWhereInput[] | ScoredTagSubscriptionWhereInput;
  OR?: ScoredTagSubscriptionWhereInput[] | ScoredTagSubscriptionWhereInput;
  NOT?: ScoredTagSubscriptionWhereInput[] | ScoredTagSubscriptionWhereInput;
}

export interface SocialAccountSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SocialAccountWhereInput;
  AND?:
    | SocialAccountSubscriptionWhereInput[]
    | SocialAccountSubscriptionWhereInput;
  OR?:
    | SocialAccountSubscriptionWhereInput[]
    | SocialAccountSubscriptionWhereInput;
  NOT?:
    | SocialAccountSubscriptionWhereInput[]
    | SocialAccountSubscriptionWhereInput;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TagWhereInput;
  AND?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  OR?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  NOT?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
}

export interface TeamSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TeamWhereInput;
  AND?: TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput;
  OR?: TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput;
  NOT?: TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Job {
  id: ID_Output;
  enabled: Boolean;
  name: String;
  header?: String;
  description?: String;
  createdAt: DateTimeOutput;
  createdByUserId: ID_Output;
  updatedAt?: DateTimeOutput;
  updatedByUserId: ID_Output;
  tags?: <T = FragmentableArray<ScoredTag>>() => T;
}

export interface JobPromise extends Promise<Job>, Fragmentable {
  id: () => Promise<ID_Output>;
  enabled: () => Promise<Boolean>;
  name: () => Promise<String>;
  header: () => Promise<String>;
  description: () => Promise<String>;
  applications: <T = FragmentableArray<Team>>(args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  createdByUserId: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  updatedByUserId: () => Promise<ID_Output>;
  tags: <T = FragmentableArray<ScoredTag>>() => T;
}

export interface JobSubscription
  extends Promise<AsyncIterator<Job>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  header: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  applications: <T = Promise<AsyncIterator<TeamSubscription>>>(args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdByUserId: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedByUserId: () => Promise<AsyncIterator<ID_Output>>;
  tags: <T = Promise<AsyncIterator<ScoredTagSubscription>>>() => T;
}

export interface Team {
  id: ID_Output;
  enabled: Boolean;
  name: String;
  header?: String;
  description?: String;
  createdAt: DateTimeOutput;
  createdByUserId: ID_Output;
  updatedAt?: DateTimeOutput;
  updatedByUserId: ID_Output;
  members?: <T = FragmentableArray<Member>>() => T;
  tags?: <T = FragmentableArray<ScoredTag>>() => T;
}

export interface TeamPromise extends Promise<Team>, Fragmentable {
  id: () => Promise<ID_Output>;
  enabled: () => Promise<Boolean>;
  name: () => Promise<String>;
  header: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  createdByUserId: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  updatedByUserId: () => Promise<ID_Output>;
  members: <T = FragmentableArray<Member>>() => T;
  jobsAppliedTo: <T = FragmentableArray<Job>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<ScoredTag>>() => T;
}

export interface TeamSubscription
  extends Promise<AsyncIterator<Team>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  header: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdByUserId: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedByUserId: () => Promise<AsyncIterator<ID_Output>>;
  members: <T = Promise<AsyncIterator<MemberSubscription>>>() => T;
  jobsAppliedTo: <T = Promise<AsyncIterator<JobSubscription>>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = Promise<AsyncIterator<ScoredTagSubscription>>>() => T;
}

export interface Member {
  role: RoleType;
  noticePeriod?: Int;
  availableAt?: DateTimeOutput;
}

export interface MemberPromise extends Promise<Member>, Fragmentable {
  user: <T = UserPromise>() => T;
  role: () => Promise<RoleType>;
  noticePeriod: () => Promise<Int>;
  availableAt: () => Promise<DateTimeOutput>;
}

export interface MemberSubscription
  extends Promise<AsyncIterator<Member>>,
    Fragmentable {
  user: <T = UserSubscription>() => T;
  role: () => Promise<AsyncIterator<RoleType>>;
  noticePeriod: () => Promise<AsyncIterator<Int>>;
  availableAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface User {
  id: ID_Output;
  email?: String;
  available: Boolean;
  firstName: String;
  lastName: String;
  description: String;
  socialAccounts?: <T = FragmentableArray<SocialAccount>>() => T;
  createdAt: DateTimeOutput;
  createdByUserId: ID_Output;
  updatedAt?: DateTimeOutput;
  updatedByUserId: ID_Output;
  tags?: <T = FragmentableArray<ScoredTag>>() => T;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  available: () => Promise<Boolean>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  description: () => Promise<String>;
  socialAccounts: <T = FragmentableArray<SocialAccount>>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  createdByUserId: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  updatedByUserId: () => Promise<ID_Output>;
  jobsCreated: <T = FragmentableArray<Job>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<ScoredTag>>() => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  available: () => Promise<AsyncIterator<Boolean>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  socialAccounts: <
    T = Promise<AsyncIterator<SocialAccountSubscription>>
  >() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdByUserId: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedByUserId: () => Promise<AsyncIterator<ID_Output>>;
  jobsCreated: <T = Promise<AsyncIterator<JobSubscription>>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = Promise<AsyncIterator<ScoredTagSubscription>>>() => T;
}

export interface SocialAccount {
  externalId: String;
  type: SocialAccountType;
}

export interface SocialAccountPromise
  extends Promise<SocialAccount>,
    Fragmentable {
  externalId: () => Promise<String>;
  type: () => Promise<SocialAccountType>;
}

export interface SocialAccountSubscription
  extends Promise<AsyncIterator<SocialAccount>>,
    Fragmentable {
  externalId: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<SocialAccountType>>;
}

export interface ScoredTag {
  score?: Int;
}

export interface ScoredTagPromise extends Promise<ScoredTag>, Fragmentable {
  score: () => Promise<Int>;
  tag: <T = TagPromise>() => T;
}

export interface ScoredTagSubscription
  extends Promise<AsyncIterator<ScoredTag>>,
    Fragmentable {
  score: () => Promise<AsyncIterator<Int>>;
  tag: <T = TagSubscription>() => T;
}

export interface Tag {
  id: ID_Output;
  name: String;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface JobConnection {
  pageInfo: PageInfo;
  edges: JobEdge[];
}

export interface JobConnectionPromise
  extends Promise<JobConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JobEdge>>() => T;
  aggregate: <T = AggregateJobPromise>() => T;
}

export interface JobConnectionSubscription
  extends Promise<AsyncIterator<JobConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JobEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJobSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface JobEdge {
  node: Job;
  cursor: String;
}

export interface JobEdgePromise extends Promise<JobEdge>, Fragmentable {
  node: <T = JobPromise>() => T;
  cursor: () => Promise<String>;
}

export interface JobEdgeSubscription
  extends Promise<AsyncIterator<JobEdge>>,
    Fragmentable {
  node: <T = JobSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateJob {
  count: Int;
}

export interface AggregateJobPromise
  extends Promise<AggregateJob>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJobSubscription
  extends Promise<AsyncIterator<AggregateJob>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TeamConnection {
  pageInfo: PageInfo;
  edges: TeamEdge[];
}

export interface TeamConnectionPromise
  extends Promise<TeamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TeamEdge>>() => T;
  aggregate: <T = AggregateTeamPromise>() => T;
}

export interface TeamConnectionSubscription
  extends Promise<AsyncIterator<TeamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TeamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTeamSubscription>() => T;
}

export interface TeamEdge {
  node: Team;
  cursor: String;
}

export interface TeamEdgePromise extends Promise<TeamEdge>, Fragmentable {
  node: <T = TeamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TeamEdgeSubscription
  extends Promise<AsyncIterator<TeamEdge>>,
    Fragmentable {
  node: <T = TeamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTeam {
  count: Int;
}

export interface AggregateTeamPromise
  extends Promise<AggregateTeam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTeamSubscription
  extends Promise<AsyncIterator<AggregateTeam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface JobSubscriptionPayload {
  mutation: MutationType;
  node: Job;
  updatedFields: String[];
  previousValues: JobPreviousValues;
}

export interface JobSubscriptionPayloadPromise
  extends Promise<JobSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JobPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JobPreviousValuesPromise>() => T;
}

export interface JobSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JobSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JobSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JobPreviousValuesSubscription>() => T;
}

export interface JobPreviousValues {
  id: ID_Output;
  enabled: Boolean;
  name: String;
  header?: String;
  description?: String;
  createdAt: DateTimeOutput;
  createdByUserId: ID_Output;
  updatedAt?: DateTimeOutput;
  updatedByUserId: ID_Output;
}

export interface JobPreviousValuesPromise
  extends Promise<JobPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  enabled: () => Promise<Boolean>;
  name: () => Promise<String>;
  header: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  createdByUserId: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  updatedByUserId: () => Promise<ID_Output>;
}

export interface JobPreviousValuesSubscription
  extends Promise<AsyncIterator<JobPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  header: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdByUserId: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedByUserId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface MemberSubscriptionPayload {
  mutation: MutationType;
  node: Member;
  updatedFields: String[];
  previousValues: MemberPreviousValues;
}

export interface MemberSubscriptionPayloadPromise
  extends Promise<MemberSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MemberPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MemberPreviousValuesPromise>() => T;
}

export interface MemberSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MemberSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MemberSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MemberPreviousValuesSubscription>() => T;
}

export interface MemberPreviousValues {
  role: RoleType;
  noticePeriod?: Int;
  availableAt?: DateTimeOutput;
}

export interface MemberPreviousValuesPromise
  extends Promise<MemberPreviousValues>,
    Fragmentable {
  role: () => Promise<RoleType>;
  noticePeriod: () => Promise<Int>;
  availableAt: () => Promise<DateTimeOutput>;
}

export interface MemberPreviousValuesSubscription
  extends Promise<AsyncIterator<MemberPreviousValues>>,
    Fragmentable {
  role: () => Promise<AsyncIterator<RoleType>>;
  noticePeriod: () => Promise<AsyncIterator<Int>>;
  availableAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ScoredTagSubscriptionPayload {
  mutation: MutationType;
  node: ScoredTag;
  updatedFields: String[];
  previousValues: ScoredTagPreviousValues;
}

export interface ScoredTagSubscriptionPayloadPromise
  extends Promise<ScoredTagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScoredTagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScoredTagPreviousValuesPromise>() => T;
}

export interface ScoredTagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScoredTagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScoredTagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScoredTagPreviousValuesSubscription>() => T;
}

export interface ScoredTagPreviousValues {
  score?: Int;
}

export interface ScoredTagPreviousValuesPromise
  extends Promise<ScoredTagPreviousValues>,
    Fragmentable {
  score: () => Promise<Int>;
}

export interface ScoredTagPreviousValuesSubscription
  extends Promise<AsyncIterator<ScoredTagPreviousValues>>,
    Fragmentable {
  score: () => Promise<AsyncIterator<Int>>;
}

export interface SocialAccountSubscriptionPayload {
  mutation: MutationType;
  node: SocialAccount;
  updatedFields: String[];
  previousValues: SocialAccountPreviousValues;
}

export interface SocialAccountSubscriptionPayloadPromise
  extends Promise<SocialAccountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SocialAccountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SocialAccountPreviousValuesPromise>() => T;
}

export interface SocialAccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SocialAccountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SocialAccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SocialAccountPreviousValuesSubscription>() => T;
}

export interface SocialAccountPreviousValues {
  externalId: String;
  type: SocialAccountType;
}

export interface SocialAccountPreviousValuesPromise
  extends Promise<SocialAccountPreviousValues>,
    Fragmentable {
  externalId: () => Promise<String>;
  type: () => Promise<SocialAccountType>;
}

export interface SocialAccountPreviousValuesSubscription
  extends Promise<AsyncIterator<SocialAccountPreviousValues>>,
    Fragmentable {
  externalId: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<SocialAccountType>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface TagPreviousValues {
  id: ID_Output;
  name: String;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface TeamSubscriptionPayload {
  mutation: MutationType;
  node: Team;
  updatedFields: String[];
  previousValues: TeamPreviousValues;
}

export interface TeamSubscriptionPayloadPromise
  extends Promise<TeamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TeamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TeamPreviousValuesPromise>() => T;
}

export interface TeamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TeamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TeamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TeamPreviousValuesSubscription>() => T;
}

export interface TeamPreviousValues {
  id: ID_Output;
  enabled: Boolean;
  name: String;
  header?: String;
  description?: String;
  createdAt: DateTimeOutput;
  createdByUserId: ID_Output;
  updatedAt?: DateTimeOutput;
  updatedByUserId: ID_Output;
}

export interface TeamPreviousValuesPromise
  extends Promise<TeamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  enabled: () => Promise<Boolean>;
  name: () => Promise<String>;
  header: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  createdByUserId: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  updatedByUserId: () => Promise<ID_Output>;
}

export interface TeamPreviousValuesSubscription
  extends Promise<AsyncIterator<TeamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  header: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdByUserId: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedByUserId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email?: String;
  available: Boolean;
  firstName: String;
  lastName: String;
  description: String;
  createdAt: DateTimeOutput;
  createdByUserId: ID_Output;
  updatedAt?: DateTimeOutput;
  updatedByUserId: ID_Output;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  available: () => Promise<Boolean>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  createdByUserId: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  updatedByUserId: () => Promise<ID_Output>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  available: () => Promise<AsyncIterator<Boolean>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdByUserId: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedByUserId: () => Promise<AsyncIterator<ID_Output>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Job",
    embedded: false
  },
  {
    name: "Member",
    embedded: true
  },
  {
    name: "RoleType",
    embedded: false
  },
  {
    name: "ScoredTag",
    embedded: true
  },
  {
    name: "SocialAccount",
    embedded: true
  },
  {
    name: "SocialAccountType",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "Team",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
